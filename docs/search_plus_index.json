{"./":{"url":"./","title":"前言","keywords":"","body":"前言 学习笔记 "},"note/mei-ri-yi-ti/202009/22.html":{"url":"note/mei-ri-yi-ti/202009/22.html","title":"22.监控二叉树","keywords":"","body":"22.监控二叉树 题目描述 给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视 其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。 解题思路 递归 约定如果某棵树的所有节点都被监控，则称该树被[覆盖]。 假设当前节点为root，其左右孩子为left，right。如果要覆盖以root为根的树，有两种情况： 若在root处安放摄像头，则孩子left，right一定也会被监控到。此时，只需要保证left的两棵子树被覆盖，同时保证right的两棵子树也被覆盖。 如果root不安放摄像头，则除了覆盖root的两棵子树以外，孩子left，right之一必须要安装摄像头，从而保证root被监控到。 因此，对于每个节点root，需要维护三种类型的状态： a：root必须放置摄像头的情况下，覆盖整棵树需要的摄像头数目。 b：覆盖整棵树需要的摄像头数目，无论root是否放置摄像头。 c：覆盖两棵子树需要的摄像头数目，无论root本身是否被监控到。 根据定义可知，一定有a >= b >= c。 对于节点root，假设其左右孩子left，right对应的状态变量为（la,lb,lc）以及（ra,rb,rc）。因此： a = lc + rc +1 b = min(a,min(la + rb,ra + lb)) 对于c而言，要保证两棵子树被完全覆盖，要么root处放置一个摄像头，即a；要么root处不放摄像头，此时两棵子树分别保证自己被覆盖，需要的摄像头为lb + rb。 c = min(a,lb + rb) 如果root的孩子为null，则该孩子对应的变量a返回一个大整数，用于标识不可能的情形。 最终，根节点的状态变量b即为要求出的答案 Code： class Solution{ public int minCameraCover(TreeNode root){ int[] array = dfs(root); return array[1]; } public int[] dfs(TreeNode root){ if(root == null){ return new int[]{Integer.MAX_VALUE / 2,0,0}; } int[] leftArray = dfs(root.left); int[] rightArray = dfs(root.right); int[] array = new int[3]; array[0] = leftArray[2] + rightArray[2] + 1; array[1] = Math.min(array[0],Math.min(leftArray[0] + rightArray[1],leftArray[1] + rightArray[0])); array[2] = Math.min(array[0],leftArray[1] + rightArray[1]); return array; } } "},"note/mei-ri-yi-ti/202009/23.html":{"url":"note/mei-ri-yi-ti/202009/23.html","title":"23.合并二叉树","keywords":"","body":"23.合并二叉树 题目描述 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会覆盖。你需要将它们合并为一个新的二叉树.合并的规则是如果两个节点重叠，那么将它们的值作为节点合并后的新值。否则不为NULL的节点将直接作为新二叉树的节点。 解题思路 深度优先（递归） 假设两个二叉树分别为t1和t2，则可以直接对t1和t2进行深度优先遍历，比较两棵树的每个节点a和b，比较的结果有三种情况： 若a和b都不为空，则新树的此节点的值为a+b，继续比较下一层。 若a和b其中一个为空，则新树的此节点为其中的非空节点，无需继续比较。 若a和b都为空，则新树的此节点为空，无需继续比较。 Code： class Solution{ public TreeNode mergeTrees(TreeNode t1,TreeNode t2){ //情况2 if(t1 == null){ return t2; } //情况2 if(t2 == null){ return t1; } //情况1 TreeNode ans = new TreeNode(t1.val + t2.val); ans.left = mergeTrees(t1.left,t2.left); ans.right = mergeTrees(t1.right,t2.right); return ans; } } "},"note/mei-ri-yi-ti/202009/24.html":{"url":"note/mei-ri-yi-ti/202009/24.html","title":"24.二叉搜索树中的众数","keywords":"","body":"24.二叉搜索树中的众数 题目描述 给定一个有相同值的二叉搜索树（BST），找出BST中的所有众数（出现频率最高的元素）。 BST定义如下： 结点左子树中所含结点的值小于等于当前结点的值。 结点右子树中所含结点的值大于等于当前结点的值。 左子树和右子树都是二叉搜索树。 解题思路 中序遍历 首先明确一个概念，一棵BST的中序遍历序列是一个非递减的有序序列。而且重复出现的数字一定是连续出现的。所以，我们可以顺序扫描中序遍历序列，用 base记录当前的数字，用count记录当前数字重复的次数，用maxCount来维护已经扫描过的数当中出现最多的那个数字的出现次数，用answer数组记录出现的众数。每次扫描到一个新的元素： 首先更新base和count： 如果该元素和base相等，那么count自增1 否则将base更新为当前数字，count复位为1 然后更新maxCount： 如果count = maxCount，那么说明当前的这个数字（base）出现的次数等于当前众数出现的次数，将base加入answer数组 如果count > maxCount，那么说明当前的这个数字（base）出现的次数大于当前众数出现的次数，因此，将maxCount更新为count，清空answer数组后将base加入answer数组 将上述操作封装成一个函数，剩下的就是解决中序遍历的问题。 普通的中序遍历，空间复杂度为O(n),而Morris中序遍历可以把空间复杂度优化到O(1)。 Morris中序遍历可以在遍历完左子树之后回到当前节点。我们希望当前的节点在遍历完当前点的前驱之后被遍历，我们可以考虑修改它的前驱结点的right指针。当前节点的前驱结点的right指针可能本来就指向当前节点（前驱是当前节点的父节点），也可能是当前节点左子树最右下的节点。如果是后者，我们希望遍历完这个前驱结点之后再回到当前节点，可以将它的right指针指向当前节点。 Morris中序遍历的一个重要步骤就是寻找当前节点的前驱节点，并且Morris中序遍历寻找下一个点始终是通过转移到right指针指向的位置来完成的。 如果当前节点没有左子树，则遍历这个点，然后跳转到当前节点的右子树。 如果当前节点有左子树，那么它的前驱节点一定在左子树上，我们可以在左子树上一直向右走，找到当前点的前驱节点。 如果前驱节点没有右子树，就将前驱结点的right指针指向当前节点。这一步是为了在遍历完前驱节点后能找到前驱节点的后继，也就是当前节点。 如果前驱节点的右子树为当前节点，说明前驱节点已经被遍历过并被修改了right指针，这个时候我们重新将前驱的右孩子设置为空，遍历当前的点，然后跳转到当前节点的右子树。 Code： class Solution{ int base,count,maxCount; List ans = new ArrayList<>(); public int[] findMode(TreeNode root){ TreeNode cur = root,pre = null; while(cur != null){ if(cur.left == null){ update(cur.val); cur = cur.right; continue; } pre = cur.left; while(pre.right != null && pre.right != cur){ pre = pre.right; } if(pre.right == null){ pre.right = cur; cur = cur.left; }else{ pre.right = null; update(cur.val); cur = cur.right; } } int[] res = new int[ans.size()]; for(int i = 0;i maxCount){ maxCount = count; ans.clear(); ans.add(base); } } } "},"note/note.html":{"url":"note/note.html","title":"note","keywords":"","body":"内部类 静态内部类 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化。 成员内部类 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。 局部内部类 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量 匿名内部类 没有类名的内部类，不能使用class，extends和implements，没有构造方法 多用于GUI中的事件处理 不能定义静态资源 只能创建一个匿名内部类实例 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效 抽象类和接口 一个子类只能继承一个抽象类，但能实现多个接口 抽象类可以有构造方法，接口没有构造方法 抽象类可以有普通成员变量，接口没有普通成员变量 抽象类和接口都可有静态成员变量，抽象类中静态成员变量访问类型任意，接口只能public static final（默认） 抽象类中可以没有抽象方法，抽象类可以有普通方法，接口中都是抽象方法 抽象类可以有静态方法，接口不能有静态方法 抽象类中的方法可以是 public、protected;接口方法只要public Map 1.线程安全的map Hash Table,SynchronizedMap,ConcurrentHashMap 单例 线程安全 饿汉式 懒汉式 枚举 静态内部类 双检锁模式 线程对象 创建 继承Thread类，重载run方法 实现Runnable接口，实现run方法 "}}