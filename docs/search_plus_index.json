{"./":{"url":"./","title":"前言","keywords":"","body":"前言 学习笔记 "},"note/mei-ri-yi-ti/202009/22.html":{"url":"note/mei-ri-yi-ti/202009/22.html","title":"22.监控二叉树","keywords":"","body":"22.监控二叉树 题目描述 给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视 其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。 解题思路 递归 约定如果某棵树的所有节点都被监控，则称该树被[覆盖]。 假设当前节点为root，其左右孩子为left，right。如果要覆盖以root为根的树，有两种情况： 若在root处安放摄像头，则孩子left，right一定也会被监控到。此时，只需要保证left的两棵子树被覆盖，同时保证right的两棵子树也被覆盖。 如果root不安放摄像头，则除了覆盖root的两棵子树以外，孩子left，right之一必须要安装摄像头，从而保证root被监控到。 因此，对于每个节点root，需要维护三种类型的状态： a：root必须放置摄像头的情况下，覆盖整棵树需要的摄像头数目。 b：覆盖整棵树需要的摄像头数目，无论root是否放置摄像头。 c：覆盖两棵子树需要的摄像头数目，无论root本身是否被监控到。 根据定义可知，一定有a >= b >= c。 对于节点root，假设其左右孩子left，right对应的状态变量为（la,lb,lc）以及（ra,rb,rc）。因此： a = lc + rc +1 b = min(a,min(la + rb,ra + lb)) 对于c而言，要保证两棵子树被完全覆盖，要么root处放置一个摄像头，即a；要么root处不放摄像头，此时两棵子树分别保证自己被覆盖，需要的摄像头为lb + rb。 c = min(a,lb + rb) 如果root的孩子为null，则该孩子对应的变量a返回一个大整数，用于标识不可能的情形。 最终，根节点的状态变量b即为要求出的答案 Code： class Solution{ public int minCameraCover(TreeNode root){ int[] array = dfs(root); return array[1]; } public int[] dfs(TreeNode root){ if(root == null){ return new int[]{Integer.MAX_VALUE / 2,0,0}; } int[] leftArray = dfs(root.left); int[] rightArray = dfs(root.right); int[] array = new int[3]; array[0] = leftArray[2] + rightArray[2] + 1; array[1] = Math.min(array[0],Math.min(leftArray[0] + rightArray[1],leftArray[1] + rightArray[0])); array[2] = Math.min(array[0],leftArray[1] + rightArray[1]); return array; } } "},"note/note.html":{"url":"note/note.html","title":"note","keywords":"","body":"内部类 静态内部类 静态内部类本身可以访问外部的静态资源，包括静态私有资源。但是不能访问非静态资源，可以不依赖外部类实例而实例化。 成员内部类 成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类。 局部内部类 局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰 局部内部类只能访问所在代码块或者方法中被定义为final的局部变量 匿名内部类 没有类名的内部类，不能使用class，extends和implements，没有构造方法 多用于GUI中的事件处理 不能定义静态资源 只能创建一个匿名内部类实例 一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口 匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效 抽象类和接口 一个子类只能继承一个抽象类，但能实现多个接口 抽象类可以有构造方法，接口没有构造方法 抽象类可以有普通成员变量，接口没有普通成员变量 抽象类和接口都可有静态成员变量，抽象类中静态成员变量访问类型任意，接口只能public static final（默认） 抽象类中可以没有抽象方法，抽象类可以有普通方法，接口中都是抽象方法 抽象类可以有静态方法，接口不能有静态方法 抽象类中的方法可以是 public、protected;接口方法只要public Map 1.线程安全的map Hash Table,SynchronizedMap,ConcurrentHashMap 单例 线程安全 饿汉式 懒汉式 枚举 静态内部类 双检锁模式 线程对象 创建 继承Thread类，重载run方法 实现Runnable接口，实现run方法 "}}